<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        #game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 20px;
            max-width: 1200px;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 15px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        #game-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 1.2em;
            font-weight: bold;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #game-canvas {
            border: 3px solid #667eea;
            border-radius: 10px;
            display: block;
            margin: 0 auto;
            cursor: crosshair;
            background: #e8f5e9;
        }

        #tower-menu {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .tower-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .tower-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .tower-btn:active:not(:disabled) {
            transform: translateY(-1px);
        }

        .tower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tower-btn.selected {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 0 20px rgba(245, 87, 108, 0.5);
        }

        #control-btns {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        .control-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #game-over {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            z-index: 1000;
        }

        #game-over h2 {
            color: #f5576c;
            font-size: 3em;
            margin-bottom: 20px;
        }

        #game-over p {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #333;
        }

        .tooltip {
            font-size: 0.8em;
            display: block;
            margin-top: 5px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>üè∞ Tower Defense üè∞</h1>
        
        <div id="game-info">
            <div class="info-item">
                <span>üí∞ Gold:</span>
                <span id="gold">500</span>
            </div>
            <div class="info-item">
                <span>‚ù§Ô∏è Leben:</span>
                <span id="lives">40</span>
            </div>
            <div class="info-item">
                <span>üåä Welle:</span>
                <span id="wave">1</span>
            </div>
            <div class="info-item">
                <span>üëæ Gegner:</span>
                <span id="enemies">0</span>
            </div>
        </div>

        <canvas id="game-canvas" width="900" height="600"></canvas>

        <div id="tower-menu">
            <button class="tower-btn" data-tower="basic">
                üóº Basis Turm
                <span class="tooltip">50 Gold | Schaden: 10</span>
            </button>
            <button class="tower-btn" data-tower="sniper">
                üéØ Sniper Turm
                <span class="tooltip">100 Gold | Schaden: 50 | Langsam</span>
            </button>
            <button class="tower-btn" data-tower="rapid">
                ‚ö° Schnellfeuer Turm
                <span class="tooltip">80 Gold | Schaden: 5 | Sehr schnell</span>
            </button>
            <button class="tower-btn" data-tower="freeze">
                ‚ùÑÔ∏è Eis Turm
                <span class="tooltip">120 Gold | Verlangsamt Gegner</span>
            </button>
            <button class="tower-btn" data-tower="cannon">
                üí£ Kanone
                <span class="tooltip">150 Gold | Fl√§chenschaden</span>
            </button>
        </div>

        <div id="control-btns">
            <button class="control-btn" id="start-wave">‚ñ∂Ô∏è Welle starten</button>
            <button class="control-btn" id="cancel-tower">‚ùå Abbrechen</button>
        </div>
    </div>

    <div id="game-over">
        <h2>Game Over!</h2>
        <p id="final-score"></p>
        <button class="control-btn" onclick="location.reload()">üîÑ Nochmal spielen</button>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Spiel-Status
        let gold = 500;
        let lives = 40;
        let wave = 0;
        let score = 0;
        let selectedTower = null;
        let gameRunning = true;
        let waveActive = false;

        // Arrays f√ºr Spielobjekte
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];

        // Pfad-Definition (mehrere Kurven)
        const path = [
            {x: 0, y: 100},
            {x: 200, y: 100},
            {x: 200, y: 300},
            {x: 400, y: 300},
            {x: 400, y: 150},
            {x: 650, y: 150},
            {x: 650, y: 400},
            {x: 900, y: 400}
        ];

        // Tower-Typen
        const towerTypes = {
            basic: {
                cost: 50,
                damage: 10,
                range: 120,
                fireRate: 1000,
                color: '#2196F3',
                projectileColor: '#FFC107',
                projectileSpeed: 5
            },
            sniper: {
                cost: 100,
                damage: 50,
                range: 200,
                fireRate: 2000,
                color: '#4CAF50',
                projectileColor: '#FF5722',
                projectileSpeed: 8
            },
            rapid: {
                cost: 80,
                damage: 5,
                range: 100,
                fireRate: 300,
                color: '#FF9800',
                projectileColor: '#FFEB3B',
                projectileSpeed: 6
            },
            freeze: {
                cost: 120,
                damage: 5,
                range: 130,
                fireRate: 1500,
                color: '#00BCD4',
                projectileColor: '#B3E5FC',
                projectileSpeed: 4,
                slow: 0.5
            },
            cannon: {
                cost: 150,
                damage: 30,
                range: 140,
                fireRate: 2000,
                color: '#9C27B0',
                projectileColor: '#E91E63',
                projectileSpeed: 3,
                splash: 80
            }
        };

        // Gegner-Typen
        const enemyTypes = [
            { hp: 30, speed: 0.4, reward: 10, color: '#E91E63', size: 12 },
            { hp: 60, speed: 0.35, reward: 20, color: '#9C27B0', size: 15 },
            { hp: 120, speed: 0.3, reward: 40, color: '#673AB7', size: 18 },
            { hp: 180, speed: 0.4, reward: 50, color: '#F44336', size: 20 },
            { hp: 300, speed: 0.25, reward: 80, color: '#FF5722', size: 25 }
        ];

        // Klassen
        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.properties = towerTypes[type];
                this.lastFire = 0;
                this.target = null;
                this.angle = 0;
            }

            update(currentTime) {
                // Ziel finden
                this.target = this.findTarget();
                
                if (this.target && currentTime - this.lastFire > this.properties.fireRate) {
                    this.fire();
                    this.lastFire = currentTime;
                }

                // Winkel zum Ziel berechnen
                if (this.target) {
                    this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                }
            }

            findTarget() {
                let closest = null;
                let closestDist = Infinity;

                for (let enemy of enemies) {
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < this.properties.range && enemy.pathProgress > (closest?.pathProgress || -1)) {
                        closest = enemy;
                        closestDist = dist;
                    }
                }

                return closest;
            }

            fire() {
                if (this.target) {
                    projectiles.push(new Projectile(
                        this.x, 
                        this.y, 
                        this.target,
                        this.properties
                    ));
                }
            }

            draw() {
                // Reichweite zeichnen (wenn ausgew√§hlt)
                if (selectedTower === this) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.properties.range, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.stroke();
                }

                // Turmbasis
                ctx.fillStyle = this.properties.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Turmkanone
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = '#333';
                ctx.fillRect(10, -5, 20, 10);
                ctx.restore();
            }
        }

        class Enemy {
            constructor(type, waveNumber) {
                const enemyType = enemyTypes[Math.min(type, enemyTypes.length - 1)];
                this.maxHp = enemyType.hp * (1 + waveNumber * 0.15);
                this.hp = this.maxHp;
                this.speed = enemyType.speed;
                this.reward = enemyType.reward;
                this.color = enemyType.color;
                this.size = enemyType.size;
                this.pathProgress = 0;
                this.x = path[0].x;
                this.y = path[0].y;
                this.slowEffect = 1;
                this.slowTimer = 0;
            }

            update() {
                // Verlangsamungs-Effekt verringern
                if (this.slowTimer > 0) {
                    this.slowTimer--;
                } else {
                    this.slowEffect = 1;
                }

                // Bewegung entlang des Pfades
                this.pathProgress += (this.speed * this.slowEffect) / 100;
                
                if (this.pathProgress >= 1) {
                    // Gegner hat das Ende erreicht
                    lives--;
                    updateUI();
                    return false;
                }

                const pos = this.getPositionOnPath(this.pathProgress);
                this.x = pos.x;
                this.y = pos.y;

                return true;
            }

            getPositionOnPath(progress) {
                const totalSegments = path.length - 1;
                const segment = Math.floor(progress * totalSegments);
                const segmentProgress = (progress * totalSegments) - segment;

                if (segment >= totalSegments) {
                    return path[path.length - 1];
                }

                const start = path[segment];
                const end = path[segment + 1];

                return {
                    x: start.x + (end.x - start.x) * segmentProgress,
                    y: start.y + (end.y - start.y) * segmentProgress
                };
            }

            takeDamage(damage, slow = 0) {
                this.hp -= damage;
                
                if (slow > 0) {
                    this.slowEffect = slow;
                    this.slowTimer = 60; // 1 Sekunde bei 60 FPS
                }

                if (this.hp <= 0) {
                    gold += this.reward;
                    score += this.reward;
                    createExplosion(this.x, this.y, this.color);
                    updateUI();
                    return true;
                }
                return false;
            }

            draw() {
                // Gegner
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lebensbalken
                const barWidth = this.size * 2;
                const barHeight = 5;
                const hpPercent = this.hp / this.maxHp;

                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 10, barWidth, barHeight);
                ctx.fillStyle = hpPercent > 0.5 ? '#4CAF50' : hpPercent > 0.25 ? '#FFC107' : '#F44336';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 10, barWidth * hpPercent, barHeight);

                // Verlangsamungs-Effekt
                if (this.slowEffect < 1) {
                    ctx.fillStyle = 'rgba(0, 188, 212, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Projectile {
            constructor(x, y, target, properties) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.properties = properties;
                this.speed = properties.projectileSpeed;
                
                // Zielposition speichern (f√ºr den Fall, dass das Ziel stirbt)
                this.targetX = target.x;
                this.targetY = target.y;
            }

            update() {
                // Aktualisiere Zielposition, falls Ziel noch lebt
                if (this.target && enemies.includes(this.target)) {
                    this.targetX = this.target.x;
                    this.targetY = this.target.y;
                }

                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < this.speed) {
                    // Treffer!
                    this.hit();
                    return false;
                }

                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;

                return true;
            }

            hit() {
                if (this.properties.splash) {
                    // Fl√§chenschaden
                    const enemiesHit = [];
                    for (let enemy of enemies) {
                        const dist = Math.hypot(enemy.x - this.targetX, enemy.y - this.targetY);
                        if (dist < this.properties.splash) {
                            if (enemy.takeDamage(this.properties.damage)) {
                                enemiesHit.push(enemy);
                            }
                        }
                    }
                    // Tote Gegner entfernen
                    for (let deadEnemy of enemiesHit) {
                        const index = enemies.indexOf(deadEnemy);
                        if (index > -1) {
                            enemies.splice(index, 1);
                        }
                    }
                    createExplosion(this.targetX, this.targetY, this.properties.projectileColor, 20);
                } else if (this.target && enemies.includes(this.target)) {
                    if (this.target.takeDamage(
                        this.properties.damage, 
                        this.properties.slow || 0
                    )) {
                        // Gegner ist tot, aus Array entfernen
                        const index = enemies.indexOf(this.target);
                        if (index > -1) {
                            enemies.splice(index, 1);
                        }
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.properties.projectileColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = Math.random() * 5 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                return this.life > 0;
            }

            draw() {
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Hilfsfunktionen
        function createExplosion(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function drawPath() {
            ctx.strokeStyle = '#8D6E63';
            ctx.lineWidth = 40;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();

            // Pfad-Rand
            ctx.strokeStyle = '#5D4037';
            ctx.lineWidth = 44;
            ctx.stroke();
            ctx.strokeStyle = '#8D6E63';
            ctx.lineWidth = 40;
            ctx.stroke();
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function canPlaceTower(x, y) {
            // Pr√ºfen ob auf dem Pfad
            for (let i = 0; i < path.length - 1; i++) {
                const start = path[i];
                const end = path[i + 1];
                const dist = distanceToSegment(x, y, start.x, start.y, end.x, end.y);
                if (dist < 40) return false;
            }

            // Pr√ºfen ob zu nah an anderen T√ºrmen
            for (let tower of towers) {
                const dist = Math.hypot(tower.x - x, tower.y - y);
                if (dist < 45) return false;
            }

            return true;
        }

        function distanceToSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len2 = dx * dx + dy * dy;
            let t = ((px - x1) * dx + (py - y1) * dy) / len2;
            t = Math.max(0, Math.min(1, t));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            return Math.hypot(px - projX, py - projY);
        }

        function spawnWave() {
            wave++;
            waveActive = true;
            
            const enemyCount = 5 + wave * 3;
            const spawnDelay = Math.max(500, 1500 - wave * 50);
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    const enemyType = Math.min(Math.floor(wave / 3), enemyTypes.length - 1);
                    enemies.push(new Enemy(enemyType, wave));
                    updateUI();
                    
                    // Pr√ºfen ob das der letzte Gegner der Welle war
                    if (i === enemyCount - 1) {
                        setTimeout(() => {
                            if (enemies.length === 0) {
                                waveActive = false;
                                gold += 50; // Bonus f√ºr abgeschlossene Welle
                                updateUI();
                            }
                        }, 2000);
                    }
                }, i * spawnDelay);
            }
            
            updateUI();
        }

        function updateUI() {
            document.getElementById('gold').textContent = gold;
            document.getElementById('lives').textContent = lives;
            document.getElementById('wave').textContent = wave;
            document.getElementById('enemies').textContent = enemies.length;

            // Tower-Buttons aktivieren/deaktivieren
            document.querySelectorAll('.tower-btn').forEach(btn => {
                const towerType = btn.dataset.tower;
                btn.disabled = gold < towerTypes[towerType].cost;
            });

            // Game Over pr√ºfen
            if (lives <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('final-score').textContent = `Welle ${wave} erreicht! Punktzahl: ${score}`;
            document.getElementById('game-over').style.display = 'block';
        }

        // Event Listeners
        canvas.addEventListener('click', (e) => {
            if (!gameRunning) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (selectedTower) {
                const towerData = towerTypes[selectedTower];
                if (gold >= towerData.cost && canPlaceTower(x, y)) {
                    towers.push(new Tower(x, y, selectedTower));
                    gold -= towerData.cost;
                    updateUI();
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!gameRunning || !selectedTower) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Preview zeichnen
            canvas.style.cursor = canPlaceTower(x, y) ? 'crosshair' : 'not-allowed';
        });

        document.querySelectorAll('.tower-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const towerType = btn.dataset.tower;
                
                document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
                
                if (selectedTower === towerType) {
                    selectedTower = null;
                } else {
                    selectedTower = towerType;
                    btn.classList.add('selected');
                }
            });
        });

        document.getElementById('start-wave').addEventListener('click', () => {
            if (!waveActive && gameRunning) {
                spawnWave();
            }
        });

        document.getElementById('cancel-tower').addEventListener('click', () => {
            selectedTower = null;
            document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
        });

        // Spiel-Loop
        function gameLoop() {
            if (!gameRunning) return;

            // Hintergrund l√∂schen
            ctx.fillStyle = '#e8f5e9';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid zeichnen
            drawGrid();

            // Pfad zeichnen
            drawPath();

            const currentTime = Date.now();

            // T√ºrme updaten und zeichnen
            for (let tower of towers) {
                tower.update(currentTime);
                tower.draw();
            }

            // Gegner updaten und zeichnen
            enemies = enemies.filter(enemy => {
                const alive = enemy.update();
                if (alive) {
                    enemy.draw();
                }
                return alive;
            });

            // Projektile updaten und zeichnen
            projectiles = projectiles.filter(proj => {
                const active = proj.update();
                if (active) {
                    proj.draw();
                }
                return active;
            });

            // Partikel updaten und zeichnen
            particles = particles.filter(particle => {
                const active = particle.update();
                if (active) {
                    particle.draw();
                }
                return active;
            });

            // Tower-Vorschau zeichnen
            if (selectedTower) {
                const rect = canvas.getBoundingClientRect();
                canvas.addEventListener('mousemove', drawPreview);
            }

            // Pr√ºfen ob Welle vorbei ist
            if (waveActive && enemies.length === 0 && projectiles.length === 0) {
                waveActive = false;
                updateUI();
            }

            requestAnimationFrame(gameLoop);
        }

        function drawPreview(e) {
            if (!selectedTower) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const towerData = towerTypes[selectedTower];
            const canPlace = canPlaceTower(x, y);

            // Reichweite
            ctx.beginPath();
            ctx.arc(x, y, towerData.range, 0, Math.PI * 2);
            ctx.fillStyle = canPlace ? 'rgba(76, 175, 80, 0.2)' : 'rgba(244, 67, 54, 0.2)';
            ctx.fill();
            ctx.strokeStyle = canPlace ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)';
            ctx.stroke();

            // Turm-Vorschau
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = towerData.color;
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        // Spiel starten
        updateUI();
        gameLoop();
    </script>
</body>
</html>
