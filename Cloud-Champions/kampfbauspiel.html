<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kampfbauspiel - Baue und K√§mpfe!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 15px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .health-bars {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
        }

        .player-health {
            flex: 1;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 1.2em;
        }

        .player1-name {
            color: #e74c3c;
        }

        .player2-name {
            color: #3498db;
            text-align: right;
        }

        .health-bar-container {
            width: 100%;
            height: 30px;
            background: #ddd;
            border-radius: 15px;
            overflow: hidden;
            border: 3px solid #333;
            position: relative;
        }

        .health-bar {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 12px;
        }

        .player1-health {
            background: linear-gradient(90deg, #e74c3c 0%, #c0392b 100%);
        }

        .player2-health {
            background: linear-gradient(90deg, #3498db 0%, #2980b9 100%);
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            font-size: 0.9em;
        }

        .vs-text {
            font-size: 2em;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #gameCanvas {
            border: 3px solid #333;
            border-radius: 10px;
            display: block;
            width: 100%;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 70%, #90EE90 100%);
            cursor: crosshair;
        }

        .block-selector {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .block-btn {
            width: 50px;
            height: 50px;
            border: 3px solid #333;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-size: 0.7em;
            text-align: center;
            padding: 3px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .block-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .block-btn.active {
            border-color: #FFD700;
            border-width: 4px;
            box-shadow: 0 0 15px #FFD700;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            margin-top: 20px;
            gap: 15px;
        }

        .control-panel {
            padding: 12px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        .control-panel h3 {
            margin-bottom: 8px;
            color: #333;
            text-align: center;
            font-size: 1em;
        }

        .player1-controls h3 {
            color: #e74c3c;
        }

        .player2-controls h3 {
            color: #3498db;
        }

        .control-panel p {
            margin: 3px 0;
            font-size: 0.8em;
            color: #555;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .winner {
            color: #f39c12;
            font-size: 2em;
            margin: 20px 0;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .round-info {
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .info-panel {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            padding: 10px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border-radius: 10px;
            color: white;
            font-size: 0.9em;
            font-weight: bold;
        }

        .combo-indicator {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .combo-indicator.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>‚öîÔ∏èüèóÔ∏è Kampfbauspiel - Baue & K√§mpfe! üèóÔ∏è‚öîÔ∏è</h1>
        
        <div class="round-info">
            Runde <span id="round">1</span> | Baue Plattformen & K√§mpfe!
        </div>

        <div class="health-bars">
            <div class="player-health">
                <div class="player-name player1-name">ü•ä Spieler 1</div>
                <div class="health-bar-container">
                    <div class="health-bar player1-health" id="player1Health" style="width: 100%;"></div>
                    <div class="health-text"><span id="player1HealthText">100</span> / 100</div>
                </div>
            </div>
            
            <div class="vs-text">VS</div>
            
            <div class="player-health">
                <div class="player-name player2-name">Spieler 2 ü•ã</div>
                <div class="health-bar-container">
                    <div class="health-bar player2-health" id="player2Health" style="width: 100%;"></div>
                    <div class="health-text"><span id="player2HealthText">100</span> / 100</div>
                </div>
            </div>
        </div>

        <div class="block-selector">
            <div class="block-btn active" data-block="dirt" style="background: #8B4513; color: white;" title="Erde">
                üü´<br><small>Erde</small>
            </div>
            <div class="block-btn" data-block="stone" style="background: #808080; color: white;" title="Stein">
                ‚¨ú<br><small>Stein</small>
            </div>
            <div class="block-btn" data-block="wood" style="background: #DEB887;" title="Holz">
                üü®<br><small>Holz</small>
            </div>
            <div class="block-btn" data-block="brick" style="background: #B22222; color: white;" title="Ziegel">
                üü•<br><small>Ziegel</small>
            </div>
            <div class="block-btn" data-block="gold" style="background: #FFD700;" title="Gold">
                ‚ú®<br><small>Gold</small>
            </div>
            <div class="block-btn" data-block="eraser" style="background: white; color: red;" title="Radiergummi">
                ‚ùå<br><small>L√∂schen</small>
            </div>
        </div>

        <canvas id="gameCanvas" width="1160" height="500"></canvas>

        <div class="info-panel">
            <div>üì¶ Platzierte Bl√∂cke: <span id="blockCount">0</span></div>
            <div>üé® Aktueller Block: <span id="currentBlock">Erde</span></div>
        </div>

        <div class="controls">
            <div class="control-panel player1-controls">
                <h3>ü•ä Spieler 1</h3>
                <p>‚¨ÖÔ∏è <strong>A/D</strong> - Bewegen</p>
                <p>‚¨ÜÔ∏è <strong>W</strong> - Springen</p>
                <p>üëä <strong>C</strong> - Schlag</p>
                <p>ü¶µ <strong>V</strong> - Tritt</p>
                <p>üí• <strong>B</strong> - Spezial</p>
            </div>

            <div class="control-panel">
                <h3>üèóÔ∏è Bauen</h3>
                <p>üñ±Ô∏è <strong>Linksklick</strong> - Platzieren</p>
                <p>üñ±Ô∏è <strong>Rechtsklick</strong> - Entfernen</p>
                <p>üé® <strong>Oben</strong> - Block w√§hlen</p>
                <p>üí° Baue Fallen, Mauern, Treppen!</p>
            </div>

            <div class="control-panel player2-controls">
                <h3>Spieler 2 ü•ã</h3>
                <p>Bewegen - <strong>‚óÄ/‚ñ∂</strong> ‚¨ÖÔ∏è‚û°Ô∏è</p>
                <p>Springen - <strong>‚ñ≤</strong> ‚¨ÜÔ∏è</p>
                <p>Schlag - <strong>1</strong> üëä</p>
                <p>Tritt - <strong>2</strong> ü¶µ</p>
                <p>Spezial - <strong>3</strong> üí•</p>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>K.O.!</h2>
        <div class="winner" id="winnerText">Spieler 1 gewinnt!</div>
        <button id="restartBtn">Neue Runde</button>
    </div>

    <div class="combo-indicator" id="comboIndicator"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Grid-System f√ºr Bl√∂cke
        const BLOCK_SIZE = 32;
        const GRID_WIDTH = Math.floor(canvas.width / BLOCK_SIZE);
        const GRID_HEIGHT = Math.floor(canvas.height / BLOCK_SIZE);

        // Spielzustand
        let gameOver = false;
        let round = 1;
        const maxRounds = 3;
        let player1Wins = 0;
        let player2Wins = 0;
        let blocks = {};
        let selectedBlock = 'dirt';
        let blockCount = 0;

        // Blocktypen
        const blockTypes = {
            dirt: { color: '#8B4513', name: 'Erde', solid: true },
            stone: { color: '#808080', name: 'Stein', solid: true },
            wood: { color: '#DEB887', name: 'Holz', solid: true },
            brick: { color: '#B22222', name: 'Ziegel', solid: true },
            gold: { color: '#FFD700', name: 'Gold', solid: true }
        };

        // K√§mpfer-Klasse
        class Fighter {
            constructor(x, y, color, controls) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 70;
                this.color = color;
                this.health = 100;
                this.maxHealth = 100;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = 5;
                this.jumpPower = 13;
                this.gravity = 0.6;
                this.onGround = false;
                this.controls = controls;
                this.attacking = false;
                this.attackCooldown = 0;
                this.attackType = null;
                this.facing = 'right';
                this.specialEnergy = 100;
                this.hitStun = 0;
                this.combo = 0;
            }

            draw() {
                // Schatten
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(this.x + this.width / 2, this.y + this.height + 5, this.width / 2, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // K√∂rper
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Kopf
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y - 10, 18, 0, Math.PI * 2);
                ctx.fill();

                // Augen
                ctx.fillStyle = '#000';
                const eyeOffset = this.facing === 'right' ? 4 : -4;
                ctx.fillRect(this.x + this.width / 2 - 7 + eyeOffset, this.y - 14, 4, 4);
                ctx.fillRect(this.x + this.width / 2 + 3 + eyeOffset, this.y - 14, 4, 4);

                // Arme
                ctx.fillStyle = this.color;
                if (this.attacking) {
                    const armExtend = this.facing === 'right' ? this.width : -25;
                    ctx.fillRect(this.x + (this.facing === 'right' ? this.width : 0), this.y + 15, armExtend, 12);
                    
                    // Angriffseffekt
                    if (this.attackType === 'punch') {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                        ctx.beginPath();
                        ctx.arc(
                            this.x + (this.facing === 'right' ? this.width + 25 : -25),
                            this.y + 21,
                            12,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (this.attackType === 'kick') {
                        ctx.fillStyle = 'rgba(255, 69, 0, 0.5)';
                        ctx.fillRect(
                            this.x + (this.facing === 'right' ? this.width : -35),
                            this.y + 35,
                            35,
                            12
                        );
                    } else if (this.attackType === 'special') {
                        ctx.fillStyle = 'rgba(0, 191, 255, 0.7)';
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.arc(
                                this.x + (this.facing === 'right' ? this.width + 25 + i * 18 : -25 - i * 18),
                                this.y + 35,
                                18 - i * 4,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                } else {
                    ctx.fillRect(this.x - 8, this.y + 15, 12, 8);
                    ctx.fillRect(this.x + this.width - 4, this.y + 15, 12, 8);
                }

                // Beine
                ctx.fillRect(this.x + 6, this.y + this.height, 12, 18);
                ctx.fillRect(this.x + this.width - 18, this.y + this.height, 12, 18);
            }

            update(keys, opponent) {
                if (gameOver || this.hitStun > 0) {
                    if (this.hitStun > 0) this.hitStun--;
                    this.applyPhysics();
                    return;
                }

                // Bewegung
                if (keys[this.controls.left] && this.x > 0) {
                    this.velocityX = -this.speed;
                    this.facing = 'left';
                }
                if (keys[this.controls.right] && this.x < canvas.width - this.width) {
                    this.velocityX = this.speed;
                    this.facing = 'right';
                }

                // Automatische Ausrichtung zum Gegner
                if (opponent.x > this.x) {
                    this.facing = 'right';
                } else {
                    this.facing = 'left';
                }

                // Springen
                if (keys[this.controls.jump] && this.onGround) {
                    this.velocityY = -this.jumpPower;
                    this.onGround = false;
                }

                // Angriffe
                if (this.attackCooldown === 0) {
                    if (keys[this.controls.punch]) {
                        this.attack('punch', 8, 5, opponent);
                    } else if (keys[this.controls.kick]) {
                        this.attack('kick', 12, 10, opponent);
                    } else if (keys[this.controls.special] && this.specialEnergy >= 30) {
                        this.attack('special', 25, 20, opponent);
                        this.specialEnergy -= 30;
                    }
                }

                // Angriffsabklingzeit
                if (this.attackCooldown > 0) {
                    this.attackCooldown--;
                    if (this.attackCooldown === 0) {
                        this.attacking = false;
                        this.attackType = null;
                    }
                }

                // Spezialenergie regenerieren
                if (this.specialEnergy < 100) {
                    this.specialEnergy += 0.2;
                }

                this.applyPhysics();
            }

            applyPhysics() {
                // Schwerkraft
                this.velocityY += this.gravity;
                if (this.velocityY > 15) this.velocityY = 15;

                this.y += this.velocityY;
                this.x += this.velocityX;

                // Bildschirm-Grenzen
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) {
                    this.x = canvas.width - this.width;
                }

                // Kollision mit Bl√∂cken
                this.onGround = false;
                this.checkBlockCollisions();

                // Reibung
                this.velocityX *= 0.8;
            }

            checkBlockCollisions() {
                const playerGridLeft = Math.floor(this.x / BLOCK_SIZE);
                const playerGridRight = Math.floor((this.x + this.width) / BLOCK_SIZE);
                const playerGridTop = Math.floor(this.y / BLOCK_SIZE);
                const playerGridBottom = Math.floor((this.y + this.height) / BLOCK_SIZE);

                for (let gridY = Math.max(0, playerGridTop - 1); gridY <= Math.min(GRID_HEIGHT - 1, playerGridBottom + 1); gridY++) {
                    for (let gridX = Math.max(0, playerGridLeft - 1); gridX <= Math.min(GRID_WIDTH - 1, playerGridRight + 1); gridX++) {
                        const block = getBlock(gridX, gridY);
                        if (block && blockTypes[block] && blockTypes[block].solid) {
                            const blockLeft = gridX * BLOCK_SIZE;
                            const blockRight = blockLeft + BLOCK_SIZE;
                            const blockTop = gridY * BLOCK_SIZE;
                            const blockBottom = blockTop + BLOCK_SIZE;

                            if (this.x < blockRight &&
                                this.x + this.width > blockLeft &&
                                this.y < blockBottom &&
                                this.y + this.height > blockTop) {
                                
                                // Von oben auf Block fallen
                                if (this.velocityY > 0 && this.y + this.height - this.velocityY <= blockTop) {
                                    this.y = blockTop - this.height;
                                    this.velocityY = 0;
                                    this.onGround = true;
                                }
                                // Von unten gegen Block springen
                                else if (this.velocityY < 0 && this.y - this.velocityY >= blockBottom) {
                                    this.y = blockBottom;
                                    this.velocityY = 0;
                                }
                                // Seitliche Kollision von links
                                else if (this.velocityX > 0 && this.x + this.width - this.velocityX <= blockLeft) {
                                    this.x = blockLeft - this.width;
                                    this.velocityX = 0;
                                }
                                // Seitliche Kollision von rechts
                                else if (this.velocityX < 0 && this.x - this.velocityX >= blockRight) {
                                    this.x = blockRight;
                                    this.velocityX = 0;
                                }
                            }
                        }
                    }
                }

                // Aus dem Bildschirm gefallen
                if (this.y > canvas.height + 50) {
                    this.takeDamage(20);
                    this.y = 50;
                    this.velocityX = 0;
                    this.velocityY = 0;
                }
            }

            attack(type, damage, cooldown, opponent) {
                this.attacking = true;
                this.attackType = type;
                this.attackCooldown = cooldown;

                let hitRange = 55;
                if (type === 'kick') hitRange = 65;
                if (type === 'special') hitRange = 90;

                const distance = Math.abs(this.x - opponent.x);
                const verticalDistance = Math.abs(this.y - opponent.y);
                
                const attacking_from_right = this.facing === 'right' && opponent.x > this.x;
                const attacking_from_left = this.facing === 'left' && opponent.x < this.x;
                
                if (distance < hitRange && verticalDistance < 50 && (attacking_from_right || attacking_from_left)) {
                    opponent.takeDamage(damage);
                    this.combo++;
                    showCombo(this.combo);
                    
                    const knockback = this.facing === 'right' ? 12 : -12;
                    opponent.velocityX = knockback;
                    opponent.hitStun = 10;
                } else {
                    this.combo = 0;
                }
            }

            takeDamage(damage) {
                this.health -= damage;
                if (this.health < 0) this.health = 0;
                updateHealthBars();
                
                if (this.health === 0) {
                    endRound();
                }
            }

            reset(x) {
                this.x = x;
                this.y = 50;
                this.health = 100;
                this.velocityX = 0;
                this.velocityY = 0;
                this.attacking = false;
                this.attackCooldown = 0;
                this.specialEnergy = 100;
                this.combo = 0;
                this.hitStun = 0;
            }
        }

        // Block-Funktionen
        function setBlock(gridX, gridY, type) {
            if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                const key = `${gridX},${gridY}`;
                blocks[key] = type;
            }
        }

        function removeBlock(gridX, gridY) {
            const key = `${gridX},${gridY}`;
            if (blocks[key]) {
                delete blocks[key];
            }
        }

        function getBlock(gridX, gridY) {
            const key = `${gridX},${gridY}`;
            return blocks[key] || null;
        }

        function updateBlockCount() {
            blockCount = Object.keys(blocks).length;
            document.getElementById('blockCount').textContent = blockCount;
        }

        // Welt initialisieren
        function initWorld() {
            blocks = {};
            // Basis-Boden
            for (let x = 0; x < GRID_WIDTH; x++) {
                setBlock(x, GRID_HEIGHT - 1, 'dirt');
                setBlock(x, GRID_HEIGHT - 2, 'stone');
            }
            
            // Start-Plattformen
            for (let x = 5; x < 10; x++) {
                setBlock(x, 10, 'wood');
            }
            
            for (let x = 26; x < 31; x++) {
                setBlock(x, 10, 'wood');
            }
            
            updateBlockCount();
        }

        // Spieler erstellen
        const player1 = new Fighter(100, 50, '#e74c3c', {
            left: 'a',
            right: 'd',
            jump: 'w',
            punch: 'c',
            kick: 'v',
            special: 'b'
        });

        const player2 = new Fighter(canvas.width - 140, 50, '#3498db', {
            left: 'ArrowLeft',
            right: 'ArrowRight',
            jump: 'ArrowUp',
            punch: '1',
            kick: '2',
            special: '3'
        });

        // Tastatureingaben
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });

        // Maus-Events f√ºr Bauen
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const gridX = Math.floor(x / BLOCK_SIZE);
            const gridY = Math.floor(y / BLOCK_SIZE);

            if (selectedBlock === 'eraser') {
                removeBlock(gridX, gridY);
            } else {
                const blockX = gridX * BLOCK_SIZE;
                const blockY = gridY * BLOCK_SIZE;
                
                // Pr√ºfe Kollision mit Spielern
                const collision1 = !(player1.x + player1.width <= blockX ||
                                   player1.x >= blockX + BLOCK_SIZE ||
                                   player1.y + player1.height <= blockY ||
                                   player1.y >= blockY + BLOCK_SIZE);
                
                const collision2 = !(player2.x + player2.width <= blockX ||
                                   player2.x >= blockX + BLOCK_SIZE ||
                                   player2.y + player2.height <= blockY ||
                                   player2.y >= blockY + BLOCK_SIZE);
                
                if (!collision1 && !collision2) {
                    setBlock(gridX, gridY, selectedBlock);
                }
            }
            updateBlockCount();
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const gridX = Math.floor(x / BLOCK_SIZE);
            const gridY = Math.floor(y / BLOCK_SIZE);
            
            removeBlock(gridX, gridY);
            updateBlockCount();
        });

        // Block-Auswahl
        document.querySelectorAll('.block-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.block-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                selectedBlock = btn.dataset.block;
                const blockName = selectedBlock === 'eraser' ? 'Radiergummi' : blockTypes[selectedBlock].name;
                document.getElementById('currentBlock').textContent = blockName;
            });
        });

        // Hintergrund zeichnen
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#E0F6FF');
            gradient.addColorStop(1, '#90EE90');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Sonne
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(100, 70, 35, 0, Math.PI * 2);
            ctx.fill();

            // Grid-Linien (subtil)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += BLOCK_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += BLOCK_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Bl√∂cke zeichnen
        function drawBlocks() {
            for (const [key, type] of Object.entries(blocks)) {
                const [gridX, gridY] = key.split(',').map(Number);
                const x = gridX * BLOCK_SIZE;
                const y = gridY * BLOCK_SIZE;
                
                ctx.fillStyle = blockTypes[type].color;
                ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
                
                // Block-Rand
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
                
                // Block-Details
                if (type === 'brick') {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y + BLOCK_SIZE / 2);
                    ctx.lineTo(x + BLOCK_SIZE, y + BLOCK_SIZE / 2);
                    ctx.stroke();
                } else if (type === 'wood') {
                    ctx.strokeStyle = 'rgba(101, 67, 33, 0.3)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 2; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x, y + i * 12);
                        ctx.lineTo(x + BLOCK_SIZE, y + i * 12);
                        ctx.stroke();
                    }
                }
            }
        }

        // Gesundheitsbalken aktualisieren
        function updateHealthBars() {
            document.getElementById('player1Health').style.width = (player1.health / player1.maxHealth * 100) + '%';
            document.getElementById('player1HealthText').textContent = Math.max(0, Math.round(player1.health));
            
            document.getElementById('player2Health').style.width = (player2.health / player2.maxHealth * 100) + '%';
            document.getElementById('player2HealthText').textContent = Math.max(0, Math.round(player2.health));
        }

        // Combo anzeigen
        function showCombo(combo) {
            if (combo < 2) return;
            
            const comboIndicator = document.getElementById('comboIndicator');
            comboIndicator.textContent = `${combo} COMBO!`;
            comboIndicator.classList.add('show');
            
            setTimeout(() => {
                comboIndicator.classList.remove('show');
            }, 800);
        }

        // Runde beenden
        function endRound() {
            gameOver = true;
            
            let winner;
            if (player1.health <= 0) {
                winner = 'Spieler 2';
                player2Wins++;
            } else {
                winner = 'Spieler 1';
                player1Wins++;
            }

            if (player1Wins >= 2 || player2Wins >= 2) {
                document.getElementById('winnerText').textContent = `${winner} gewinnt das Match! (${player1Wins}:${player2Wins})`;
            } else {
                document.getElementById('winnerText').textContent = `${winner} gewinnt Runde ${round}! (${player1Wins}:${player2Wins})`;
            }
            
            document.getElementById('gameOver').classList.add('show');
        }

        // Neustart
        document.getElementById('restartBtn').addEventListener('click', () => {
            if (player1Wins >= 2 || player2Wins >= 2) {
                round = 1;
                player1Wins = 0;
                player2Wins = 0;
                initWorld();
            } else {
                round++;
            }
            
            document.getElementById('round').textContent = round;
            document.getElementById('gameOver').classList.remove('show');
            player1.reset(100);
            player2.reset(canvas.width - 140);
            updateHealthBars();
            gameOver = false;
        });

        // Spiel-Loop
        function gameLoop() {
            drawBackground();
            drawBlocks();
            
            player1.update(keys, player2);
            player2.update(keys, player1);
            
            player1.draw();
            player2.draw();
            
            requestAnimationFrame(gameLoop);
        }

        // Spiel starten
        initWorld();
        gameLoop();
    </script>
</body>
</html>

